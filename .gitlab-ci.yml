# GitLab CI/CD Pipeline for Movie Recommender System
# Triggered ONLY on: Merge to Main Branch (after MR is merged)

# WORKFLOW RULES - Control when pipeline runs

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"  # Test on MR
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH # After merge



# GLOBAL VARIABLES

variables:
  # Python Configuration
  variables:
  PYTHON_VERSION: "3.10"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.pip-cache"
  PYTHONPATH: "$CI_PROJECT_DIR"
  
  # Docker Configuration
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_NAME: "$CI_REGISTRY_IMAGE"
  IMAGE_TAG: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
  IMAGE_LATEST: "$CI_REGISTRY_IMAGE:latest"
  
  # Test Configuration
  PYTEST_ADDOPTS: "--color=yes"


# CACHE CONFIGURATION - Speed up pipeline runs

cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - .pip-cache/

# PIPELINE STAGES

stages:
  - test          # Run all tests (unit + integration)
  - train         # Train and evaluate models
  - build         # Build Docker image (infrastructure testing)
  - deploy        # Deploy to server (manual, only on main)


# STAGE 1: TEST

# Unit Tests - Test individual components in isolation (parallel execution using pytest)

test:unit:
  stage: test
  image: python:${PYTHON_VERSION}-slim
  before_script:
    - python -V
    - apt-get update && apt-get install -y --no-install-recommends build-essential
    - pip install --no-cache-dir pdm
    - pdm config python.use_venv false
    - pdm install --dev --no-editable
    - export PYTHONPATH="$CI_PROJECT_DIR"
    # - pip install pytest pytest-cov pytest-xdist
  script:
    - pytest -q -n auto tests/unittests --maxfail=1 --disable-warnings
             --cov=src --cov-report=term-missing --cov-report=xml
             --junitxml=pytest-unit.xml
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    when: always
    reports:
      junit: pytest-unit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.xml
    expire_in: 1 week


# Integration Tests - Test component interactions (only on main after merge)

test:integration:
  stage: test
  image: python:${PYTHON_VERSION}-slim
  needs: ["test:unit"]  # Wait for unit tests to pass first
  before_script:
    - python -V
    - apt-get update && apt-get install -y --no-install-recommends build-essential
    - pip install --no-cache-dir pdm
    - pdm config python.use_venv false
    - pdm install --dev --no-editable
    - export PYTHONPATH="$CI_PROJECT_DIR"
    # - pip install pytest pytest-cov pytest-xdist
  script:
    - pytest -q -n auto tests/integration --maxfail=1 --disable-warnings
             --cov=src --cov-append --cov-report=term-missing --cov-report=xml
             --junitxml=pytest-integration.xml
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    when: always
    reports:
      junit: pytest-integration.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.xml
    expire_in: 1 week


# STAGE 2: TRAIN & EVALUATE

# Train Model - Automatically retrain model on every merge to main

train_model:
  stage: train
  image: python:${PYTHON_VERSION}-slim
  before_script:
    - python -V
    - pip install pdm
    - pdm config python.use_venv false
    - pdm install --prod --no-editable
  script:
    - echo " Starting model training pipeline..."
    - python src/trainer.py
    - echo " Model training complete"
  artifacts:
    when: on_success
    paths:
      - src/models/preprocessor.joblib
      - src/models/xgb_model.joblib
      - src/train_results/
    expire_in: 30 days
  timeout: 2h  # Allow up to 2 hours for training


# Evaluate Model - Automatically evaluate model after training

evaluate_model:
  stage: train
  image: python:${PYTHON_VERSION}-slim
  needs: ["train_model"]  # Wait for training to complete
  before_script:
    - python -V
    - pip install --upgrade pip
    - pip install -r requirements.txt
  script:
    - echo " Running offline model evaluation..."
    - python evaluation/Offline/offline_eval.py
    - echo " Model evaluation complete"
  artifacts:
    when: always
    paths:
      - evaluation_results.json
      - evaluation/Offline/*.json
    reports:
      metrics: evaluation_results.json
    expire_in: 30 days


# STAGE 3: BUILD (Infrastructure Testing)

# Docker Build - Build and push Docker image

docker_build:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - echo "Logging in to GitLab Container Registry..."
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "Building Docker image..."
    - docker build 
        -f docker/Dockerfile 
        -t $IMAGE_TAG 
        -t $IMAGE_LATEST 
        --label "git.commit=$CI_COMMIT_SHA" 
        --label "git.branch=$CI_COMMIT_REF_NAME" 
        .
    - echo "Pushing Docker image to registry..."
    - docker push $IMAGE_TAG
    - docker push $IMAGE_LATEST
    - echo " Infrastructure test passed - Docker build successful"
    - echo "Image - $IMAGE_TAG"
  artifacts:
    when: on_success
    expire_in: 1 week

# STAGE 4: DEPLOY

# Deploy to Server - Deploy Docker container to production server

deploy_production:
  stage: deploy
  image: alpine:latest
  when: manual  # Require manual approval to deploy
  before_script:
    - apk add --no-cache openssh-client docker-cli
    - eval $(ssh-agent -s)
    - echo "$DEPLOY_SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts
  script:
    - echo "Deploying to $DEPLOY_HOST..."
    - |
      ssh $DEPLOY_USER@$DEPLOY_HOST << 'EOF'
        # Login to GitLab registry on remote server
        echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
        
        # Pull latest image
        docker pull $IMAGE_TAG
        
        # Stop and remove old container
        docker stop movie-recommender || true
        docker rm movie-recommender || true
        
        # Run new container
        docker run -d \
          --name movie-recommender \
          -p 8080:8080 \
          --restart unless-stopped \
          $IMAGE_TAG
        
        # Wait for container to start
        sleep 5
        
        # Health check
        if curl -f http://localhost:8080/health; then
          echo " Deployment successful - Health check passed"
        else
          echo " Deployment failed - Health check failed"
          exit 1
        fi
      EOF
  environment:
    name: production
    url: http://fall2025-comp585-6.cs.mcgill.ca:8080

